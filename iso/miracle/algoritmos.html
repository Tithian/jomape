<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Algoritmos de Planificaci&oacute;n</title>
</head>
<body>
<h1>ALGORITMOS DE PLANIFICACIÓN</h1>
<p>
La planificación indica al ordenador los procesos que deben ejecutarse y los estados
que deben adoptar.
</p>
<p>
Hay dos tipos de algoritmos según las transiciones entre procesos:
</p>
<ul>
<li><p>
	Los <strong>no apropiativos</strong>, son aquellos en los que los procesos que se están ejecutando
sólo suelta el procesador cuando acaba o se bloquea.
<li><p>
	Los <strong>apropiativos</strong>, son aquellos en los que un proceso que no se ha bloqueado o no
ha terminado su ejecución, puede dejar de ejecutarse porque lo decide el
planificador.
</p></li>
</ul>

<p>
Los algoritmos no apropiativos tienen el problema de que hay muchos procesos en
espera. El tiempo de espera puede ser muy lento. Tienen la ventaja de que son muy
sencillos, y para incrementarlos se incrementan con una cola.
</p>
<p>
Alguno de los algoritmos de planificación más importantes son:
</p>
<ul>
<li><p>
	<strong>Algoritmo de rueda</strong> o <strong>Round-Robin</strong>. Asigna rotativamente los mismos
tiempos de ejecución a los diferentes procesos. A cada proceso se le asigna el
mismo <strong>quantum</strong>, esto es, el mismo intervalo de tiempo de ejecución.
	<p><i>
Ejemplo: Supongamos que se están ejecutando tres procesos. Cada uno de ellos
consume un número de tiempos o ciclos de CPU: A consume 7, B 5, y C 8. El
primer proceso lanzado es A, el segundo B y el tercero C. El quantum es 1.
	</i></p>
<li><p>
	<strong>Algoritmo por prioridades</strong> o <strong>multinivel</strong>. Son los más complejos y eficaces.
Asigna los tiempos de ejecución de la CPU según una lista de prioridades. El
tiempo de ejecución del procesador se irá destinando, en primer lugar, de forma
secuencial a los procesos de mayor nivel. Terminados éstos, se ejecutarán los
procesos del nivel inferior, y así sucesivamente, hasta llegar a los procesos del
nivel más bajos.
	<p><i>
Ejemplo: Se lanzan tres procesos A, B y C, que consumen 7, 5 y 8 ciclos
respectivamente. A y C son de prioridad alta, y B de prioridad baja. Se lanza
primero A, en segundo lugar B y en tercero C.
	</i></p>
<li><p>
	<strong>Algoritmo por intervalos de espera</strong>. Según se va ejecutando el proceso, el
tiempo que la CPU le destina puede ir aumentando o disminuyendo, según la
prioridad que le hayamos asignado. Si un proceso es prioritario, irá utilizando,
según se vaya ejecutando, intervalos más largos de tiempo de ejecución de la
CPU.
	<p><i>
Ejemplo: Se lanzan tres procesos al mismo tiempo. Los ciclos que consume
cada uno son A 7, B 5 y C 8. Sea C el proceso más prioritario, B un poco menos
prioritario y A el de más baja prioridad.
	</i></p>
<li><p>
	<strong>FIFO</strong>. Primero en llegar, primero en ser servido. Es el más sencillo, pero el más
ineficaz. Los procesos se ejecutan según el orden de llegada.
	<p><i>
Ejemplo: Se lanzan tres procesos. El primer proceso lanzado es A, el segundo B
y el tercero C. Los ciclos que consumen respectivamente son 7, 5 y 8.
	</i></p>
<li><p>
	<strong>Algoritmo Shortest Remaining Time</strong> o <strong>SRT</strong>. Permite asignar el tiempo de
ejecución de forma prioritaria a procesos muy cortos para ejecutarlos en el
menor tiempo posible. Si se está ejecutando un proceso más largo, el SO le
quitará la ejecución de la CPU para asignársela al proceso más corto. De esta
forma, el usuario del proceso corto obtendrá resultados en un tiempo mínimo, y
el usuario del proceso largo casi no notará esta circunstancia.
	<p><i>
Ejemplo: Se lanzan tres procesos. El primer proceso lanzado es A, el segundo B
y el tercero C. Los ciclos que consumen respectivamente son 7, 5 y 8.
	</i></p>
<li><p>
	<strong>SPN</strong>, <strong>HRRN</strong> y <strong>Feedback</strong>
</ul>
<p>
También podemos encontrar:
</p>
<ul style="list-style-type:disclosure-closed">
	<li><p>
	Los <strong>algoritmos de colas múltiples</strong> consiste en que tenemos diferentes colas de
procesos listos para ejecutarse, en vez de tener sólo una única cola. Cada una de las
colas, tienen distinta prioridad.
	</p></li>
	<li><p>
	Los <strong>algoritmos de colas múltiples con traspaso</strong> es igual que el anterior, pero se
permite que los procesos salten de cola para conseguir que las colas de menor
prioridad puedan ejecutarse. También se le puede aumentar la prioridad a un
proceso que lleve en la cola mucho rato.
	</p></li>
</ul>
</body>
</html>